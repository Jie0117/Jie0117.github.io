<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jie Blog on </title>
    <link>https://jie0117.github.io/blog/</link>
    <description>Recent content in Jie Blog on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 03 Mar 2024 16:15:55 +0800</lastBuildDate>
    <atom:link href="https://jie0117.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>19 Remove Nth Node From End of List</title>
      <link>https://jie0117.github.io/blog/leetcode_19/</link>
      <pubDate>Sun, 03 Mar 2024 16:15:55 +0800</pubDate>
      <guid>https://jie0117.github.io/blog/leetcode_19/</guid>
      <description>題目敘述 Given the head of a linked list, remove the nth node from the end of the list and return its head.&#xA;string convert(string s, int numRows);&#xA;測試資料 Example 1: Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5]&#xA;Example 2: Input: head = [1], n = 1 Output: []&#xA;Example 3: Input: head = [1,2], n = 1 Output: [1]&#xA;限制條件 The number of nodes in the list is sz.</description>
    </item>
    <item>
      <title>Leetcode 6.Zigzag Conversion</title>
      <link>https://jie0117.github.io/blog/leetcode_6_zigzag_conversion/</link>
      <pubDate>Sat, 02 Mar 2024 17:05:55 +0800</pubDate>
      <guid>https://jie0117.github.io/blog/leetcode_6_zigzag_conversion/</guid>
      <description>題目敘述 字串 &amp;quot;PAYPALISHIRING&amp;quot; 按照給定的行數以鋸齒形模式編寫，就像這樣： （為了更好的可讀性，你可以這樣閱讀）&#xA;P A H N A P L S I I G Y I R&#xA;之後依照行順序讀取: &amp;quot;PAHNAPLSIIGYIR&amp;quot;&#xA;函數總共會有兩個參數字串s跟整數numRows&#xA;string convert(string s, int numRows);&#xA;測試資料 Example 1:&#xA;Input: s = &amp;ldquo;PAYPALISHIRING&amp;rdquo;, numRows = 3 Output: &amp;ldquo;PAHNAPLSIIGYIR&amp;rdquo;&#xA;Example 2:&#xA;Input: s = &amp;ldquo;PAYPALISHIRING&amp;rdquo;, numRows = 4 Output: &amp;ldquo;PINALSIGYAHRPI&amp;rdquo; Explanation: P I N A L S I G Y A H R P I&#xA;Example 3:&#xA;Input: s = &amp;ldquo;A&amp;rdquo;, numRows = 1 Output: &amp;ldquo;A&amp;rdquo;</description>
    </item>
    <item>
      <title>Server Proxy</title>
      <link>https://jie0117.github.io/blog/server/</link>
      <pubDate>Sat, 02 Mar 2024 11:37:36 +0800</pubDate>
      <guid>https://jie0117.github.io/blog/server/</guid>
      <description>正向代理 vs. 反向代理 當談到網路和網路服務時，&amp;ldquo;正向代理&amp;rdquo;（Forward Proxy）和&amp;quot;反向代理&amp;quot;（Reverse Proxy）是兩個常被提及的概念。這兩種代理伺服器（Proxy Server）都是在網路通訊中發揮重要作用的工具，但它們的功能和工作方式卻大不相同。對於一般使用者比較常接觸到的是正向代理(如：VPN)，而反向代理則是網站架設者會接觸到的。 接下來就讓我們來看看兩者之間的差異！&#xA;正向代理（Forward Proxy） 讓我們先從&amp;quot;正向代理&amp;quot;開始說起。正向代理通常是作為客戶端（client）與公共網路（Internet）之間的一個中間媒介。當用戶端設備（例如個人電腦、手機等）要求訪問網路上的資源時，它會先向正向代理伺服器發送請求。代理伺服器會代表客戶端向目標伺服器（例如網站、服務器等）發出請求，並將其回應返回給客戶端。簡單來說，正向代理&amp;quot;代表&amp;quot;客戶端去訪問網絡上的資源，並將收到的資源回傳給客戶端。&#xA;客戶端（Client Side） 發送一個請求（Request）到正向代理（Forward Proxy）。 正向代理 接收到這個請求後，會代表客戶端向目標伺服器（Target Server）發送另一個請求。 目標伺服器 收到請求後，處理並返回一個回應（Response）給正向代理。 正向代理 收到來自目標伺服器的回應後，再將這個回應轉發給最初的客戶端。 簡而言之，正向代理的流程是客戶端通過正向代理來訪問目標伺服器(也就是說可以對目標伺服器隱藏身分)，並將目標伺服器的回應返回給客戶端。這種代理方式通常用於控制、過濾或監視用戶端的request，也可以用於繞過某些網路限制(如：翻牆)。&#xA;反向代理（Reverse Proxy） 相反，&amp;ldquo;反向代理&amp;quot;則在伺服器端（server-side）扮演著類似的角色，但其工作方式則截然不同。當客戶端向伺服器發送請求時，這個請求會先傳送到反向代理伺服器。反向代理伺服器會根據特定的規則和配置，將這個請求轉發到適當的後端伺服器（如應用伺服器、資料庫伺服器等）。當後端伺服器返回結果時，反向代理伺服器再將這些結果轉發給最初的客戶端。簡而言之，反向代理伺服器&amp;quot;代表&amp;quot;伺服器來處理客戶端的請求，並將結果返回給客戶端。&#xA;客戶端（Client Side） 發送一個請求（Request）到反向代理（Reverse Proxy）。注意：以客戶端視角是不知道反向代理伺服器的存在。 反向代理 接收到這個請求後，會代表根據自定義規則向伺服器（Server）分配請求。 目標伺服器 收到請求後，處理並返回一個回應（Response）給反向代理。 反向代理 收到來自伺服器的回應後，再將這個回應轉發給最初的客戶端。 總體而言，反向代理在客戶端和目標伺服器之間充當了中間人的角色，但與正向代理不同的是，反向代理是代表伺服器而不是客戶端。它隱藏了後端伺服器的真實身份和結構，並可以提供負載平衡、SSL 加密、緩存等功能，以增強伺服器的效率、安全性和可擴展性。&#xA;結論 正向代理和反向代理，兩者都是代理伺服器，但在網路架構中扮演不同的角色和功能。總結這兩者的主要區別和功能：&#xA;正向代理（Forward Proxy）：&#xA;位於客戶端與網絡之間：客戶端在發送請求時，不直接連接到目標伺服器，而是透過正向代理。 隱藏客戶端身份：正向代理伺服器可以隱藏客戶端的真實IP地址和其他身份資訊。 過濾和監控：可用於過濾內容、提供安全性、加速訪問速度等功能。 代理客戶端訪問外部資源：通常用於內部網絡中，客戶端訪問外部資源時，正向代理會代表客戶端向外部伺服器發送請求。 反向代理（Reverse Proxy）：&#xA;位於目標伺服器與網絡之間：客戶端發送請求時，先連接到反向代理，再由反向代理轉發請求到目標伺服器。 隱藏伺服器身份：反向代理隱藏了目標伺服器的真實IP地址和結構，保護伺服器的安全性。 負載平衡：可以分發流量到多個後端伺服器，以提高性能和可擴展性。 SSL 終端：負責處理 SSL 加密和解密，減輕伺服器的負擔。 緩存：可以緩存靜態資源，提高資源的訪問速度和效率。 </description>
    </item>
  </channel>
</rss>
